name: Build images locally, send to Droplet & deploy (no registry)

on:
  push:
    branches: [ main ]  # cambia si usas otra rama
    paths:
      - 'api-gateway/**'
      - 'auth-service/**'
      - 'realms/telemedicine/**'
      - '.github/workflows/build-send-deploy.yml'
  workflow_dispatch: {}

jobs:
  build-and-send:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        include:
          - name: api-gateway
            context: api-gateway
            dockerfile: api-gateway/Dockerfile
            image: local/api-gateway
            path_filter: 'api-gateway/**'
          - name: auth-service
            context: auth-service
            dockerfile: auth-service/Dockerfile
            image: local/auth-service
            path_filter: 'auth-service/**'
          - name: telemedicine
            context: realms/telemedicine
            dockerfile: realms/telemedicine/Dockerfile
            image: local/telemedicine
            path_filter: 'realms/telemedicine/**'

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Detect service changes
        id: changes
        uses: dorny/paths-filter@v3
        with:
          filters: |
            service:
              - ${{ matrix.path_filter }}

      - name: Set up Docker Buildx
        if: steps.changes.outputs.service == 'true'
        uses: docker/setup-buildx-action@v3

      - name: Build image
        if: steps.changes.outputs.service == 'true'
        run: |
          DOCKER_BUILDKIT=1 docker build \
            -f "${{ matrix.dockerfile }}" \
            -t "${{ matrix.image }}:sha-${{ github.sha }}" \
            "${{ matrix.context }}"

      - name: Save & compress image
      # Guardamos como <servicio>-image.tar.gz
        if: steps.changes.outputs.service == 'true'
        run: |
          docker save "${{ matrix.image }}:sha-${{ github.sha }}" | gzip > "${{ matrix.name }}-image.tar.gz"
          ls -lh "${{ matrix.name }}-image.tar.gz"

      - name: Send image to Droplet (SCP)
        if: steps.changes.outputs.service == 'true'
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_KEY }}
          port: ${{ secrets.SSH_PORT }}
          source: "${{ matrix.name }}-image.tar.gz"
          target: "/root/images"

  deploy:
    runs-on: ubuntu-latest
    needs: build-and-send
    steps:
      - name: Deploy (load, retag to :deployed, compose up)
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_KEY }}
          port: ${{ secrets.SSH_PORT }}
          script: |
            set -e
            COMPOSE_DIR="${{ secrets.COMPOSE_DIR:-/root/telemedicine-stack }}"
            mkdir -p /root/images
            cd /root/images

            # Carga imágenes recibidas, retag a :deployed y limpia tars
            for svc in api-gateway auth-service telemedicine; do
              TAR="${svc}-image.tar.gz"
              if [ -f "$TAR" ]; then
                echo "Loading $TAR..."
                gunzip -c "$TAR" | docker load

                # Encuentra la imagen cargada con tag sha-<commit>
                IMG=$(docker image ls --format '{{.Repository}}:{{.Tag}}' | grep "local/${svc}:sha-" | head -n1 || true)
                if [ -n "$IMG" ]; then
                  # Mantén rollback: guarda el tag previo como :prev si existía
                  if docker image inspect "local/${svc}:deployed" >/dev/null 2>&1; then
                    docker tag "local/${svc}:deployed" "local/${svc}:prev" || true
                  fi
                  docker tag "$IMG" "local/${svc}:deployed"
                  echo "Retag: $IMG -> local/${svc}:deployed"
                fi
                rm -f "$TAR"
              else
                echo "No tar for ${svc}, skipping."
              fi
            done

            # Levanta/actualiza contenedores
            cd "$COMPOSE_DIR"
            docker compose up -d

            # Limpia imágenes huérfanas
            docker image prune -f
