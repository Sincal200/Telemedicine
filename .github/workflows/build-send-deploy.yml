name: Build images locally, send to Droplet & deploy (no registry)

on:
  push:
    branches: [ main ]  # cámbiala si usas otra rama
    paths:
      - 'api-gateway/**'
      - 'auth-service/**'
      - 'realms/telemedicine/**'
      - '.github/workflows/build-send-deploy.yml'
  workflow_dispatch: {}

jobs:
  build-and-send:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        include:
          - name: api-gateway
            context: api-gateway
            dockerfile: api-gateway/Dockerfile
            image: local/api-gateway
            path_filter: 'api-gateway/**'
          - name: auth-service
            context: auth-service
            dockerfile: auth-service/Dockerfile
            image: local/auth-service
            path_filter: 'auth-service/**'
          - name: telemedicine
            context: realms/telemedicine
            dockerfile: realms/telemedicine/Dockerfile
            image: local/telemedicine
            path_filter: 'realms/telemedicine/**'

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Detect service changes
        id: changes
        uses: dorny/paths-filter@v3
        with:
          filters: |
            service:
              - ${{ matrix.path_filter }}

      - name: Set up Docker Buildx
        if: steps.changes.outputs.service == 'true'
        uses: docker/setup-buildx-action@v3

      - name: Build image
        if: steps.changes.outputs.service == 'true'
        run: |
          DOCKER_BUILDKIT=1 docker build \
            -f "${{ matrix.dockerfile }}" \
            -t "${{ matrix.image }}:sha-${{ github.sha }}" \
            "${{ matrix.context }}"

      - name: Save & compress image
        if: steps.changes.outputs.service == 'true'
        run: |
          docker save "${{ matrix.image }}:sha-${{ github.sha }}" | gzip > "${{ matrix.name }}-image.tar.gz"
          ls -lh "${{ matrix.name }}-image.tar.gz"

      - name: Send image to Droplet (SCP)
        if: steps.changes.outputs.service == 'true'
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_KEY }}
          port: ${{ secrets.SSH_PORT }}
          source: "${{ matrix.name }}-image.tar.gz"
          target: "/root/images"

  deploy:
    runs-on: ubuntu-latest
    needs: build-and-send
    env:
      COMPOSE_DIR: ${{ secrets.COMPOSE_DIR }}  # si no lo defines, usamos fallback en bash
    steps:
      - name: Deploy (load, retag to :deployed, compose up)
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_KEY }}
          port: ${{ secrets.SSH_PORT }}
          script: |
            set -e

mkdir -p /root/images
cd /root/images

# Track which services were updated
UPDATED_SERVICES=""

# Carga imágenes recibidas, retag a :deployed y limpia tars
for svc in api-gateway auth-service telemedicine; do
  TAR="${svc}-image.tar.gz"
  if [ -f "$TAR" ]; then
    echo "Loading $TAR..."
    gunzip -c "$TAR" | docker load

    # Encuentra la imagen cargada con tag sha-<commit>
    IMG=$(docker image ls --format '{{.Repository}}:{{.Tag}}' | grep "local/${svc}:sha-" | head -n1 || true)
    if [ -n "$IMG" ]; then
      # Mantén rollback: guarda el tag previo como :prev si existía
      if docker image inspect "local/${svc}:deployed" >/dev/null 2>&1; then
        docker tag "local/${svc}:deployed" "local/${svc}:prev" || true
      fi
      docker tag "$IMG" "local/${svc}:deployed"
      echo "Retag: $IMG -> local/${svc}:deployed"
      UPDATED_SERVICES="$UPDATED_SERVICES $svc"
    else
      echo "No loaded image found for ${svc}"
    fi
    rm -f "$TAR"
  else
    echo "No tar for ${svc}, checking if image exists..."
    # Check if deployed image exists, if not create a placeholder or skip
    if ! docker image inspect "local/${svc}:deployed" >/dev/null 2>&1; then
      echo "WARNING: No deployed image exists for ${svc}. Service may fail to start."
    fi
  fi
done

# Fallback si COMPOSE_DIR no está definido
cd "${COMPOSE_DIR:-/root/telemedicine-stack}"

# Only update services that were actually updated, or all if none were updated but we want to start everything
if [ -n "$UPDATED_SERVICES" ]; then
  echo "Updated services: $UPDATED_SERVICES"
  echo "Restarting updated services..."
  for svc in $UPDATED_SERVICES; do
    docker compose up -d "$svc"
  done
else
  echo "No services were updated, but attempting to start all services..."
  # This might fail if images don't exist
  docker compose up -d || {
    echo "Failed to start services. Some images may be missing."
    echo "Available local images:"
    docker images | grep local/
    exit 1
  }
fi

# Limpia imágenes huérfanas
docker image prune -f

